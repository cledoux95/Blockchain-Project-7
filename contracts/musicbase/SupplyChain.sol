pragma solidity ^0.4.24;

import '../musiccore/Ownable.sol';
import '../musicaccesscontrol/MusicianRole.sol';
import '../musicaccesscontrol/ProducerRole.sol';
import '../musicaccesscontrol/DistributorRole.sol';
import '../musicaccesscontrol/ListenerRole.sol';
import 'node_modules/openzeppelin-solidity/contracts/math/SafeMath.sol';

// Define a contract 'Supplychain'
contract SupplyChain is Ownable, MusicianRole, ProducerRole, DistributorRole, ListenerRole {

/*=======================================================*/
/*                  CONTRACT VARIABLES                   */
/*=======================================================*/

  using SafeMath for uint;

  // Define 'owner'
  address owner;

  // Define a variable called 'upc' for Universal Product Code (UPC)
  uint upc;

  // Define a variable called 'sku' for Stock Keeping Unit (SKU)
  uint sku;

  // Define a public mapping 'songs' that maps the UPC to an Song.
  mapping (uint => Song) songs;

  // Define a public mapping 'songsHistory' that maps the UPC to an array of TxHash,
  // that track its journey through the supply chain -- to be sent from DApp.
  mapping (uint => string[]) songsHistory;

  // Define enum 'State' with the following values:
  enum State
  {
    Unwritten,      // 0
    MelodyWritten,  // 1
    LyricsWritten,  // 2
    Played,         // 3
    Recorded,       // 4
    Approved,       // 5
    Released,       // 6
    Received,       // 7
    Purchased       // 8
  }

  State constant defaultState = State.Unwritten;

  // Define a struct 'Song' with the following fields:
  struct Song {
    uint    sku;  // Stock Keeping Unit (SKU)
    uint    upc; // Universal Product Code (UPC), generated by the Musician, goes on the song, can be verified by the Listener
    address ownerID;  // Metamask-Ethereum address of the current owner as the product moves through 8 stages
    address originMusicianID; // Metamask-Ethereum address of the Musician
    string  originMusicianName; // Musician Name
    string  originMusicianInformation;  // Musician Information
    uint    songID;  // Product ID potentially a combination of upc + sku
    string  songNotes; // Product Notes
    uint    songPrice; // Product Price
    State   songState;  // Product State as represented in the enum above
    uint    musicianShares; // How many shares of the song revenue the musician owns
    uint    producerShares; // How many shares of the song revenue the producer owns
    uint    distributorShares; // How many shares of the song revenue the distributor owns
    address producerID; // Metamask-Ethereum address of the Retailer
    address distributorID;  // Metamask-Ethereum address of the Distributor
    address listenerID; // Metamask-Ethereum address of the Consumer
  }

  // Define 8 events with the same 8 state values and accept 'upc' as input argument
  event MelodyWritten(uint upc);
  event LyricsWritten(uint upc);
  event Played(uint upc);
  event Recorded(uint upc);
  event Approved(uint upc);
  event Released(uint upc);
  event Received(uint upc);
  event Purchased(uint upc);

/*=======================================================*/
/*                  CONTRACT MODIFIERS                   */
/*=======================================================*/

  // Define a modifer that checks to see if msg.sender == owner of the contract
  modifier onlyOwner() {
    require(msg.sender == owner, 'Only the owner of the contract can call this function');
    _;
  }

  // Define a modifer that verifies the Caller
  modifier verifyCaller (address _address) {
    require(msg.sender == _address, 'Caller is not verified to call this function');
    _;
  }

  // Define a modifier that checks if the paid amount is sufficient to cover the price
  modifier paidEnough(uint _price) {
    require(msg.value >= _price, 'Caller has not paid a sufficient amount to recieve the song');
    _;
  }

  // Define a modifier that checks the price and refunds the remaining balance
  modifier checkValue(uint _upc) {
    _;
    uint _price = songs[_upc].songPrice;
    uint amountToReturn = msg.value - _price;
    songs[_upc].listenerID.transfer(amountToReturn);
  }

  modifier sharesValidation(uint _musicianShares, uint _producerShares, uint _distributorShares) {
    require(_musicianShares >= 0, 'Cannot have negative Musician Shares');
    require(_musicianShares <= 100, 'Cannot have over 100 Musician Shares');
    require(_producerShares >= 0, 'Cannot have negative Producer Shares');
    require(_producerShares <= 100, 'Cannot have over 100 Producer Shares');
    require(_distributorShares >= 0, 'Cannot have negative Distributor Shares');
    require(_distributorShares <= 100, 'Cannot have over 100 Distributor Shares');
    require(_musicianShares.add(_producerShares).add(_distributorShares) == 100, 'Total number of ownership shares must be 100');
    _;
  }

  // Define a modifier that checks if an song.state of a upc is Harvested
  modifier isUnwritten(uint _upc) {
    require(songs[_upc].songState == State.Unwritten, 'This function requires the song to not have been written');
    _;
  }

  // Define a modifier that checks if an song.state of a upc is Harvested
  modifier melodyIsWritten(uint _upc) {
    require(songs[_upc].songState == State.MelodyWritten, 'This function requires the melody to have been written (by the Musician)');
    _;
  }

  // Define a modifier that checks if an song.state of a upc is Processed
  modifier lyricsAreWritten(uint _upc) {
    require(songs[_upc].songState == State.LyricsWritten, 'This function requires the lyrics to have been written (by the Musician)');
    _;
  }

  // Define a modifier that checks if an song.state of a upc is Packed
  modifier isPlayed(uint _upc) {
    require(songs[_upc].songState == State.Played, 'This function requires the song to have been played (by the Musician)');
    _;
  }

  // Define a modifier that checks if an song.state of a upc is ForSale
  modifier isRecorded(uint _upc) {
    require(songs[_upc].songState == State.Recorded, 'This function requires the song to have been recorded (by the Producer)');
    _;
  }

  // Define a modifier that checks if an song.state of a upc is Sold
  modifier isApproved(uint _upc) {
    require(songs[_upc].songState == State.Approved, 'This function requires the song to have been approved (by the Musician)');
    _;
  }

  // Define a modifier that checks if an song.state of a upc is Shipped
  modifier isReleased(uint _upc) {
    require(songs[_upc].songState == State.Released, 'This function requires the song to have been released (by the Producer)');
    _;
  }

  // Define a modifier that checks if an song.state of a upc is Received
  modifier isReceived(uint _upc) {
    require(songs[_upc].songState == State.Received, 'This function requires the song to have been received (by the Distributor)');
    _;
  }

  // Define a modifier that checks if an song.state of a upc is Purchased
  modifier isPurchased(uint _upc) {
    require(songs[_upc].songState == State.Purchased, 'This function requires the song to have been purchased (by the Listener)');
    _;
  }

/*=======================================================*/
/*                 CONTRACT CONSTRUCTOR                  */
/*=======================================================*/

  // In the constructor set 'owner' to the address that instantiated the contract
  // and set 'sku' to 1
  // and set 'upc' to 1
  constructor() public payable {
    owner = msg.sender;
    sku = 1;
    upc = 1;
  }

/*=======================================================*/
/*                  CONTRACT FUNCTIONS                   */
/*=======================================================*/

  // Define a function 'kill' if required
  function kill() public {
    if (msg.sender == owner) {
      selfdestruct(owner);
    }
  }

  // Define a function 'writeMelody' that allows a Musician to mark a song 'MelodyWritten'
  function writeMelody(
              uint _upc,
              address _originMusicianID,
              string _originMusicianName,
              string _originMusicianInformation,
              string _songNotes
            )
            public
            isUnwritten(_upc)
            onlyMusician
  {

    songs[_upc].sku = sku;
    songs[_upc].upc = _upc;
    songs[_upc].ownerID = _originMusicianID;
    songs[_upc].originMusicianID = _originMusicianID;
    songs[_upc].originMusicianName = _originMusicianName;
    songs[_upc].originMusicianInformation = _originMusicianInformation;
    songs[_upc].musicianShares = 100;
    songs[_upc].producerShares = 0;
    songs[_upc].distributorShares = 0;
    songs[_upc].songID = _upc + sku;
    songs[_upc].songNotes = _songNotes;
    songs[_upc].songState = State.MelodyWritten;

    // Increment sku
    sku = sku + 1;

    emit MelodyWritten(_upc);
  }

  // Define a function 'writeLyrics' that allows a  to mark a song 'LyricsWritten'
  function writeLyrics(
              uint _upc
            )
            public
            melodyIsWritten(_upc)
            verifyCaller(songs[_upc].ownerID)
            onlyMusician
  {
    songs[_upc].songState = State.LyricsWritten;
    emit LyricsWritten(_upc);
  }

  // Define a function 'playTracks' that allows a Musician to mark a song 'Played'
  function playTracks(
              uint _upc,
              uint _producerShares
            )
            public
            lyricsAreWritten(_upc)
            verifyCaller(songs[_upc].ownerID)
            onlyMusician
            sharesValidation(songs[_upc].musicianShares.sub(_producerShares), songs[_upc].producerShares.add(_producerShares), 0)
  {
    songs[_upc].musicianShares = songs[_upc].musicianShares.sub(_producerShares);
    songs[_upc].producerShares = songs[_upc].producerShares.add(_producerShares);
    songs[_upc].songState = State.Played;
    emit Played(_upc);
  }

  // Define a function 'recordTracks' that allows a Producer to mark a song 'Recorded'
  function recordTracks(
                uint _upc
              )
              public
              isPlayed(_upc)
              onlyProducer
  {
    songs[_upc].producerID = msg.sender;
    songs[_upc].songState = State.Recorded;
    emit Recorded(_upc);
  }

  // Define a function 'approveTracks' that allows a Musician to mark a song 'Approved'
  function approveTracks(
                uint _upc
              )
              public
              isRecorded(_upc)
              verifyCaller(songs[_upc].ownerID)
              onlyMusician
  {
    songs[_upc].ownerID = songs[_upc].producerID;
    songs[_upc].songState = State.Approved;
    emit Approved(_upc);
  }

  // Define a function 'releaseSong' that allows a Producer to mark a song 'Released'
  function releaseSong(
                uint _upc,
                uint _songPrice,
                uint _distributorShares
              )
              public
              isApproved(_upc)
              verifyCaller(songs[_upc].ownerID)
              onlyProducer
              sharesValidation(songs[_upc].musicianShares, songs[_upc].producerShares.sub(_distributorShares), songs[_upc].distributorShares.add(_distributorShares))
  {
    songs[_upc].producerShares = songs[_upc].producerShares.sub(_distributorShares);
    songs[_upc].distributorShares = songs[_upc].distributorShares.add(_distributorShares);
    songs[_upc].songPrice = _songPrice;
    songs[_upc].songState = State.Released;
    emit Released(_upc);
  }

  // Define a function 'receiveSong' that allows a Distributor to mark a song 'Received'
  function receiveSong(
                uint _upc
              )
              public
              isReleased(_upc)
              onlyDistributor
  {
    songs[_upc].ownerID = msg.sender;
    songs[_upc].distributorID = msg.sender;
    songs[_upc].songState = State.Received;
    emit Received(_upc);
  }

  // Define a function 'purchaseSong' that allows the Listener to mark a song 'Purchased'
  // Use the above defined modifiers to check if the song is available for sale, if the buyer has paid enough,
  // and any excess ether sent is refunded back to the buyer
  function purchaseSong(
                uint _upc
              )
              public
              payable
              isReceived(_upc)
              onlyListener
              paidEnough(songs[_upc].songPrice)
              checkValue(_upc)
  {
    songs[_upc].ownerID = msg.sender;
    songs[_upc].listenerID = msg.sender;
    songs[_upc].songState = State.Purchased;

    songs[_upc].originMusicianID.transfer(songs[_upc].songPrice.mul(songs[_upc].musicianShares).div(100));
    songs[_upc].producerID.transfer(songs[_upc].songPrice.mul(songs[_upc].producerShares).div(100));
    songs[_upc].distributorID.transfer(songs[_upc].songPrice.mul(songs[_upc].distributorShares).div(100));

    emit Purchased(_upc);
  }

  // Define a function 'fetchSongBufferOne' that fetches the data
  function fetchSongBufferOne(
              uint _upc
            )
            public
            view
            returns (
              uint    songSKU,
              uint    songUPC,
              address ownerID,
              address originMusicianID,
              string memory originMusicianName,
              string memory originMusicianInformation
            )
  {
    songSKU = songs[_upc].sku;
    songUPC = songs[_upc].upc;
    ownerID = songs[_upc].ownerID;
    originMusicianID = songs[_upc].originMusicianID;
    originMusicianName = songs[_upc].originMusicianName;
    originMusicianInformation = songs[_upc].originMusicianInformation;

    return (
      songSKU,
      songUPC,
      ownerID,
      originMusicianID,
      originMusicianName,
      originMusicianInformation
    );
  }

  // Define a function 'fetchSongBufferTwo' that fetches the data
  function fetchSongBufferTwo(
              uint _upc
            )
            public
            view
            returns(
              uint    songSKU,
              uint    songUPC,
              uint    songID,
              string memory songNotes,
              uint    songPrice,
              uint    songState,
              uint    musicianShares,
              uint    producerShares,
              uint    distributorShares,
              address producerID,
              address distributorID,
              address listenerID
            )
  {
    songSKU = songs[_upc].sku;
    songUPC = songs[_upc].upc;
    songID = songs[_upc].songID;
    songNotes = songs[_upc].songNotes;
    songPrice = songs[_upc].songPrice;
    songState = uint(songs[_upc].songState);
    musicianShares = songs[_upc].musicianShares;
    producerShares = songs[_upc].producerShares;
    distributorShares = songs[_upc].distributorShares;
    producerID = songs[_upc].producerID;
    distributorID = songs[_upc].distributorID;
    listenerID = songs[_upc].listenerID;

    return(
      songSKU,
      songUPC,
      songID,
      songNotes,
      songPrice,
      songState,
      musicianShares,
      producerShares,
      distributorShares,
      producerID,
      distributorID,
      listenerID
    );
  }
}
